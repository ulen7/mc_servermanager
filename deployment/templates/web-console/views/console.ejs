<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/style.css">
    <title>Console - Web Console</title>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Web Server Manager</h1>
            <p>Server Administration Console</p>
            <div class="server-status" id="serverStatusIndicator">‚óè Server Online</div>
        </div>
        
        <div id="consoleSection" class="console-container" style="display: block;">
            <div class="console-controls">
                <div class="btn-group">
                    <button class="btn btn-start" onclick="startServer()">‚ñ∂Ô∏è Start</button>
                    <button class="btn btn-stop" onclick="stopServer()">‚èπÔ∏è Stop</button>
                    <button class="btn btn-restart" onclick="restartServer()">üîÑ Restart</button>
                    <button class="btn btn-clear" onclick="clearConsole()">üóëÔ∏è Clear</button>
                    <button class="btn btn-secondary" onclick="toggleAutoScroll()">üìú Auto-scroll: ON</button>
                    <button class="btn btn-secondary" onclick="reconnectLogs()">üîÑ Reconnect Logs</button>
                </div>
                <div class="user-info">
                    <span id="connectionStatus">üîå Connecting...</span>
                    <span>üë§ Logged in</span>
                    <a href="/logout" class="logout-btn">Logout</a>
                </div>
            </div>
            
            <div class="server-info">
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Server Status</div>
                        <div class="info-value" id="serverStatus">Unknown</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Connection</div>
                        <div class="info-value" id="socketStatus">Connecting...</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Log Lines</div>
                        <div class="info-value" id="logCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Container</div>
                        <div class="info-value" id="containerName"><%= containerName || 'mc_server' %></div>
                    </div>
                </div>
            </div>
            
            <div class="console-output" id="consoleOutput">
                <div class="console-line info">[System] Initializing console interface...</div>
            </div>
            <div class="command-input">
                <input type="text" 
                       id="commandInput" 
                       placeholder="Enter Minecraft command... (‚Üë/‚Üì for history)" 
                       onkeypress="handleCommandInput(event)"
                       onkeydown="handleHistoryNavigation(event)">
                <button onclick="sendCommand()" id="sendBtn">Send</button>
            </div>
        </div>
    </div>

    <!-- Socket.IO Client -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    
    <script>
        // Socket.IO connection
        const socket = io();
        let autoScroll = true;
        let logCount = 0;

        // Connection event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            updateConnectionStatus('Connected', 'success');
            addConsoleMessage('success', 'Connected to log stream');
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            updateConnectionStatus('Disconnected', 'error');
            addConsoleMessage('error', 'Disconnected from server');
        });

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            updateConnectionStatus('Connection Error', 'error');
            addConsoleMessage('error', 'Connection error occurred');
        });

        // Real-time log handler
        socket.on('log', (data) => {
            // If this is a connection success message, update connection status
            if (data.type === 'success' && data.message.includes('Connected to')) {
                updateConnectionStatus('Connected', 'success');
            }
            
            addLogMessage(data);
            updateLogCount();
        });

        // Server status updates
        socket.on('serverStatus', (data) => {
            updateServerStatus(data.status, data.message);
            addConsoleMessage('info', `Server status: ${data.message}`);
        });

        // Handle log stream ending
        socket.on('logStreamEnded', (data) => {
            addConsoleMessage('warn', 'Log stream disconnected (server likely stopped)');
            updateConnectionStatus('Log Stream Ended', 'warning');
        });

        // Handle server requesting log stream restart
        socket.on('restartLogStream', () => {
            addConsoleMessage('info', 'Restarting log stream...');
            updateConnectionStatus('Reconnecting...', 'warning');
            // Request a new log stream from the server
            socket.emit('requestLogs', { tail: '50' });
        });

        // Helper function to update connection status
        function updateConnectionStatus(status, type) {
            const connectionStatus = document.getElementById('connectionStatus');
            const socketStatus = document.getElementById('socketStatus');
            
            const icons = {
                'success': 'üü¢',
                'error': 'üî¥',
                'warning': 'üü°'
            };
            
            connectionStatus.textContent = `${icons[type] || 'üîå'} ${status}`;
            socketStatus.textContent = status;
        }

        // Helper function to add log messages from Socket.IO
        function addLogMessage(data) {
            // Filter out RCON noise messages
            const message = data.message;
            
            // Skip RCON technical messages
            const rconPatterns = [
                /RCON LISTENER.*started/i,
                /RCON Client.*started/i,
                /RCON Client.*shutting down/i,
                /Thread RCON Client/i,
                /\[RCON\]/i,                    // General RCON tags
                /^\s*$/,                        // Empty lines
                /Connection.*established/i,      // Connection messages
            ];
            
            const isRconNoise = rconPatterns.some(pattern => pattern.test(message));
            if (isRconNoise) {
                return; // Skip these messages
            }
            
            const consoleOutput = document.getElementById('consoleOutput');
            const messageDiv = document.createElement('div');
            
            // Determine CSS class based on log type
            let cssClass = 'console-line';
            if (data.type === 'error') cssClass += ' error';
            else if (data.type === 'warn') cssClass += ' warning';
            else if (data.type === 'command') cssClass += ' command';
            else cssClass += ' info';
            
            messageDiv.className = cssClass;
            
            // Format timestamp
            const timestamp = new Date(data.timestamp).toLocaleTimeString();
            messageDiv.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${escapeHtml(data.message)}`;
            
            consoleOutput.appendChild(messageDiv);
            
            // Auto-scroll if enabled
            if (autoScroll) {
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        }

        // Helper function to add console messages (local)
        function addConsoleMessage(type, message) {
            const consoleOutput = document.getElementById('consoleOutput');
            const timestamp = new Date().toLocaleTimeString();
            const messageDiv = document.createElement('div');
            messageDiv.className = `console-line ${type}`;
            messageDiv.innerHTML = `<span class="timestamp">[${timestamp}]</span> [System] ${escapeHtml(message)}`;
            consoleOutput.appendChild(messageDiv);
            
            if (autoScroll) {
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
            
            updateLogCount();
        }

        // Update log count
        function updateLogCount() {
            logCount++;
            document.getElementById('logCount').textContent = logCount;
        }

        // Update server status
        function updateServerStatus(status, message) {
            const serverStatus = document.getElementById('serverStatus');
            const statusIndicator = document.getElementById('serverStatusIndicator');
            
            serverStatus.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            
            if (status === 'running') {
                statusIndicator.textContent = '‚óè Server Online';
                statusIndicator.style.color = 'green';
            } else if (status === 'stopped') {
                statusIndicator.textContent = '‚óè Server Offline';
                statusIndicator.style.color = 'red';
            } else {
                statusIndicator.textContent = '‚óè Server Unknown';
                statusIndicator.style.color = 'orange';
            }
        }

        // Server control functions
        function startServer() {
            addConsoleMessage('info', 'Starting server...');
            fetch('/api/control/start', { method: 'POST' })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        addConsoleMessage('success', 'Server start command sent');
                    } else {
                        throw new Error(data.error || 'Unknown error');
                    }
                })
                .catch(err => {
                    addConsoleMessage('error', `Failed to start server: ${err.message}`);
                });
        }

        function stopServer() {
            addConsoleMessage('info', 'Stopping server...');
            fetch('/api/control/stop', { method: 'POST' })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        addConsoleMessage('success', 'Server stop command sent');
                    } else {
                        throw new Error(data.error || 'Unknown error');
                    }
                })
                .catch(err => {
                    addConsoleMessage('error', `Failed to stop server: ${err.message}`);
                });
        }

        function restartServer() {
            addConsoleMessage('info', 'Restarting server...');
            fetch('/api/control/restart', { method: 'POST' })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        addConsoleMessage('success', 'Server restart command sent');
                    } else {
                        throw new Error(data.error || 'Unknown error');
                    }
                })
                .catch(err => {
                    addConsoleMessage('error', `Failed to restart server: ${err.message}`);
                });
        }

        // Clear console function
        function clearConsole() {
            const consoleOutput = document.getElementById('consoleOutput');
            consoleOutput.innerHTML = '';
            logCount = 0;
            updateLogCount();
            addConsoleMessage('info', 'Console cleared');
        }

        // Toggle auto-scroll
        function toggleAutoScroll() {
            autoScroll = !autoScroll;
            const btn = event.target;
            btn.textContent = `üìú Auto-scroll: ${autoScroll ? 'ON' : 'OFF'}`;
            addConsoleMessage('info', `Auto-scroll ${autoScroll ? 'enabled' : 'disabled'}`);
        }

        // Reconnect logs manually
        function reconnectLogs() {
            addConsoleMessage('info', 'Manually reconnecting to log stream...');
            socket.emit('requestLogs', { tail: '50' });
        }

        // Command input functions

        // Updated sendCommand function with history support

        function sendCommand() {
            const commandInput = document.getElementById('commandInput');
            const command = commandInput.value.trim();
            
            if (command) {
                // Add to command history BEFORE sending
                commandHistory.addCommand(command);
                
                // Add to console display
                addConsoleMessage('command', `> ${command}`);
                
                // Send to server
                fetch('/api/command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ command: command })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        if (data.output) {
                            addConsoleMessage('info', `Command output: ${data.output}`);
                        }
                    } else {
                        addConsoleMessage('error', data.error || 'Command failed');
                    }
                })
                .catch(err => {
                    addConsoleMessage('error', `Failed to execute command: ${err.message}`);
                });
                
                // Clear input
                commandInput.value = '';
                
                // Update command history statistics display
                function updateCommandHistoryStats() {
                    const count = commandHistory.getCommandCount();
                    // You can add this to your info grid or create a small indicator
                    console.log(`Command history: ${count}/50 commands stored`);
                }

// Show command history stats on page load
document.addEventListener('DOMContentLoaded', function() {
    updateCommandHistoryStats();
    addConsoleMessage('info', `Command history loaded: ${commandHistory.getCommandCount()} previous commands available`);
});
            }
        }

        // Handle Enter key in command input
        function handleCommandInput(event) {
            if (event.key === 'Enter') {
                sendCommand();
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            addConsoleMessage('info', 'Console interface loaded');
            addConsoleMessage('info', 'Connecting to real-time log stream...');
        });

        <!-- NEW COMMANDS FUNCTIONS -->

        // Command History Management

        class CommandHistory {
            constructor() {
                this.commands = this.loadFromStorage();
                this.currentIndex = -1; // -1 means "new command"
                this.tempCommand = ''; // Store current input when navigating
            }
            
            // Load commands from localStorage
            loadFromStorage() {
                try {
                    const stored = localStorage.getItem('minecraft_command_history');
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.warn('Failed to load command history:', e);
                    return [];
                }
            }
            
            // Save commands to localStorage
            saveToStorage() {
                try {
                    localStorage.setItem('minecraft_command_history', JSON.stringify(this.commands));
                } catch (e) {
                    console.warn('Failed to save command history:', e);
                }
            }
            
            // Add new command to history
            addCommand(command) {
                if (!command || command.trim() === '') return;
                
                const trimmedCommand = command.trim();
                
                // Remove command if it already exists (move to end)
                const existingIndex = this.commands.indexOf(trimmedCommand);
                if (existingIndex !== -1) {
                    this.commands.splice(existingIndex, 1);
                }
                
                // Add to end of array
                this.commands.push(trimmedCommand);
                
                // Keep only last 50 commands
                if (this.commands.length > 50) {
                    this.commands = this.commands.slice(-50);
                }
                
                // Reset navigation state
                this.currentIndex = -1;
                this.tempCommand = '';
                
                // Save to storage
                this.saveToStorage();
            }
            
            // Navigate to previous command (‚Üë)
            navigateUp() {
                if (this.commands.length === 0) return null;
                
                // If at newest position, store current input
                if (this.currentIndex === -1) {
                    this.tempCommand = document.getElementById('commandInput').value;
                }
                
                // Move up in history (towards older commands)
                if (this.currentIndex < this.commands.length - 1) {
                    this.currentIndex++;
                }
                
                return this.commands[this.commands.length - 1 - this.currentIndex];
            }
            
            // Navigate to next command (‚Üì)
            navigateDown() {
                if (this.commands.length === 0) return null;
                
                // Move down in history (towards newer commands)
                if (this.currentIndex > -1) {
                    this.currentIndex--;
                }
                
                // If back to newest position, return temp command
                if (this.currentIndex === -1) {
                    return this.tempCommand;
                }
                
                return this.commands[this.commands.length - 1 - this.currentIndex];
            }
            
            // Get current command count for display
            getCommandCount() {
                return this.commands.length;
            }
        }
        
        // Initialize command history
        const commandHistory = new CommandHistory();

        // Handle arrow key navigation for command history
        function handleHistoryNavigation(event) {
            const commandInput = document.getElementById('commandInput');
            
            // Handle arrow keys
            if (event.key === 'ArrowUp') {
                event.preventDefault(); // Prevent cursor movement
                const command = commandHistory.navigateUp();
                if (command !== null) {
                    commandInput.value = command;
                    // Move cursor to end
                    commandInput.setSelectionRange(commandInput.value.length, commandInput.value.length);
                }
                return false;
            }
            
            if (event.key === 'ArrowDown') {
                event.preventDefault(); // Prevent cursor movement
                const command = commandHistory.navigateDown();
                if (command !== null) {
                    commandInput.value = command;
                    // Move cursor to end
                    commandInput.setSelectionRange(commandInput.value.length, commandInput.value.length);
                }
                return false;
            }
        }


    </script>
</body>
</html>
